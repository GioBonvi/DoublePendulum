#!/usr/bin/env python3

# This program takes the data generated by fractal_gen and renders
# the corresponding image.
# The colors can be assigned according to different scales:
#  - linear
#  - logarithmic
#  - multilogarithmic, where the log10 of the value determines the base color
#    from a list, then for that color a gradient is defined logarithmically.

import argparse
from PIL import Image
from colour import Color
from math import sqrt, log10, log, ceil

def colorDecimalTo254(tup):
    """Converts an RGB tuple from a 0-1 scale to a 0-254 scale."""
    
    # PIL works with the 254 scale, while the colour package works with a 0-1 scale.
    return (int(tup[0] * 254), int(tup[1] * 254), int(tup[2] * 254))

parser = argparse.ArgumentParser(
    description="Generates the fractal image from the data.",
    formatter_class=argparse.RawTextHelpFormatter
)
parser.add_argument(
    "--symmetry",
    help="Enable symemtric replication of the final image.",
    choices=["x","y"]
)
parser.add_argument(
    "input_file",
    help="The input file to read the data from.",
    type=str
)
parser.add_argument(
    "output_file",
    help="The file to save the image into.",
    type=str
)
parser.add_argument(
    "--separator",
    help="The separator used by the input file.\nDefaults to \\t.",
    type=str,
    nargs="?",
    default="\t",
    const="\t"
)
parser.add_argument(
    "--basesteps",
    help="The unit number of steps to base the scale coloration on (only affects the multilog scale).\nDefaults to 1.",
    type=int,
    nargs="?",
    default=1,
    const=1
)
parser.add_argument(
    "--scale",
    help="The scale used to assign colors to the values.\nDefaults to multilog.",
    type=str,
    nargs="?",
    choices=["multilog", "log", "linear"],
    default="multilog",
    const="multilog"
)
parser.add_argument(
    "--ncolors",
    help="Limit the number of colors used in the scale.",
    type=int,
    nargs="?",
    default=None,
    const=None
)
args = parser.parse_args()

# If the color gradient is applied on the multilog scale this number of steps
# acts as a base unit of time to define the absolute scale.
# The other two scales are relative and do not need this.
base_steps = args.basesteps
# If true the final image will be composed by the image from the data and the
# same image rotated by 180Â° to its right.
# This can be used to draw the full initial conditions space while calculating
# just half of it (since the other half is rotationary simemtric)
enable_symmetry = args.symmetry
separator = args.separator

# Color gradient
color_grad_subdivisions = 1000
all_scale_colors = [
    [Color("black"), Color("black")],
    [Color("#040085"), Color("#47a9ff")], # Blue
    [Color("#00631e"), Color("#47d171")], # Green
    [Color("#8f0000"), Color("#ff8080")], # Red
    [Color("#4b0066"), Color("#e18fff")]  # Purple
]
color_outofscale = Color("white")
if args.ncolors is None or args.ncolors < 1 or args.ncolors > len(all_scale_colors):
    scale_colors = all_scale_colors
else:
    scale_colors = all_scale_colors[0:args.ncolors]

color_gradient = [color for colors in scale_colors for color in colors[0].range_to(colors[1], color_grad_subdivisions)]

# Separate the data in these lists.
row = []
col = []
value = []

# Read data from the input file.
with open(args.input_file, "r") as f:
    # Lines starting with # are comments.
    for line in f.readlines():
        if line[0] != "#":
            [c, r, v] = line.split(separator)
            row.append(int(r))
            col.append(int(c))
            value.append(int(v))

row_max = max(row)
col_max = max(col)
value_max = max(value)

# Add one last band to the color gradient, going from the last color to the out of scale color.
#color_gradient.extend(scale_colors[-1][1].range_to(color_outofscale, color_grad_subdivisions))

if not enable_symmetry:
    # No symmetry: dimensions and number of rows/columns are the same.
    row_len = row_max + 1
    col_len = col_max + 1
elif enable_symmetry == "y" and (col_max + 1) % 2 == 0:
    # Vertical symmetry and even number of columns: duplicate the columns.
    row_len = (row_max + 1) * 2
    col_len = col_max + 1
elif enable_symmetry == "y":
    # Vertical symmetry and odd number of columns: duplicate the columns
    # keeping the central one.
    row_len = row_max * 2
    col_len = col_max + 1
elif enable_symmetry == "x" and (row_max + 1) % 2 == 0:
    # Horizontal symmetry and even number of rows: duplicate the rows.
    row_len = row_max + 1
    col_len = (col_max + 1) * 2
elif enable_symmetry == "x":
    # Horizontal symmetry and odd number of rows: duplicate the rows
    # keeping the central one.
    row_len = row_max + 1
    col_len = col_max * 2
image_dimensions = (row_len, col_len)

# The background of the image is preset to color_outofscale because in the
# calculation data some points were intentionally left out: those should be
# represented as out of scale.
img = Image.new('RGB', image_dimensions, color=colorDecimalTo254(color_outofscale.get_rgb()))
for i, (r, c, v) in enumerate(zip(row, col, value)):
    color = None
    if v == value_max:
        # Without this line values which are out of scale (but not left out from the data)
        # will result in the top color of the scale instead of color_outofscale.
        color = color_outofscale
    elif args.scale == "linear":
        # Linear relative scale (minimum = first color, maximum = last color)
        color_i = int(v / value_max * (len(color_gradient) - 1))
        color = color_gradient[color_i]
    elif args.scale == "log":
        # Linear logarithmic scale (minimum = first color, maximum = last color)
        color_i = int(log10(v) / log10(value_max) * (len(color_gradient) - 1))
        color = color_gradient[color_i]
    elif args.scale == "multilog":
        # Absolute logarithmic scale: base color is decided by the integer part of
        # log10(v / base_steps), tint by the decimal part.
        if v == 0:
            color = color_outofscale
        else:
            color_i = log10(v / base_steps) + 1
            if color_i < 0:
                # No negative values.
                color_i = 0
            color_i = int(color_i * color_grad_subdivisions)

            if color_i >= len(color_gradient):
                color = color_outofscale
            else:
                color = color_gradient[color_i]
    new_pixel = colorDecimalTo254(color.get_rgb())

    img.putpixel((c, r), new_pixel)
    if enable_symmetry:
        # Also place the pixel in the symmetric position.
        img.putpixel((col_len - 1 - c, row_len - 1 - r), new_pixel)
img.save(args.output_file)